<!DOCTYPE html>
<html>
  <head>
    <title>Advanced functions</title>
  </head>
  <body>
    <button class="js-button">Click</button>
    <script>
        const myBtn = document.querySelector('.js-button');
        const eventListener = ()=>{
            console.log('clicked')
        }
        myBtn.addEventListener('click', eventListener); // eventListeners are preferred over onclick attributes.
        myBtn.removeEventListener('click', eventListener)
        myBtn.addEventListener('click', ()=>{
            console.log('clicked with second method')
        });
        /*
        greeting()
        function greeting() {
            console.log('hello')
        }
        greeting()
        // function definition as such allows for HOISTING == being able to call the function before its definition; hoisting doesnt work when saving a function as a value of a variable

        // functions are values!!!

        const num = 2;
        const function1 = function () {
            console.log('hello 2');
        };

        console.log(function1)
        console.log(typeof function1)
        function1()

        // function can be saved inside an object, which makes it a method of that object.
        const object1 = {
            num: 2,
            fun: function() {
                console.log('hello 3')
            }
        }
        object1.fun()

        function display(param){
            console.log(param)
        }
        display(2);

        // passing a function into another function as a parameter
        function run(param){
            param();
        }

        run(function(){
            console.log('hello 4') // function that is being passed in run() is a callback function == CALLBACK
        })
            */

        // setTimeout() allows to run a function in the future

        // setTimeout(function(){
        //     // sync code inside setTimeout(async)
        //     console.log('timeout')
        //     setTimeout(function(){
        //         console.log("another timeout")
        //     }, 3000)
        // }, 3000)

        /*
        // asynchronous code -- the computer doesn't wait for the first line to finish before running the next one. 
        // Synchronous code is the opposite -- computer waits for the result of the current function to move on to the next.
        console.log('next line')

        // another async function, runs function every interval
        let interval = 0
        setInterval(function(){
            // console.log('interval')
        }, interval) // only takes the variable interval once and doesn't change it over the course of usage

        // function run(){
        //     console.log('interval: ', interval)
        //     setTimeout(run, interval)
        //     interval += 10
        // }

        // run()
        
        const object2 = {
            method: ()=>{ //arrow function syntax

            },
            method() { // shorthand method syntax
                
            }
        }

        // .forEach method to loop through the array (preferred to loop through an array)
        [
            'make dinner',
            'wash dishes',
            'watch youtube'
        ].forEach(function(value, index){
            if(value === 'wash dishes')
                return  // the same as continue in a regular loop
                        // doesnt support break, use regular loop if break is required!
            console.log(value, ':', index)
        })
        */


// LESSON 12 p2 == ADVANCED FUNCTIONS
    /*
        const arrowFunction = (param, param2) => {
            console.log('hello');
            return 5;
        }
        const regularFunction = function(param, param2){
            console.log('hello');
            return 5;
        }

        arrowFunction();

        const oneParam= param=>{
            console.log(param + 1);
        };

        // oneParam(2)

        const oneLine= () => 2 + 3;
        console.log(oneLine());

        [
            'make dinner',
            'wash dishes',
            'watch youtube'
        ].forEach((value, index) => console.log(value, ':', index));


        const object3={
            method: ()=>{
                // not this
            },
            method() {
                // this syntax is recommended
            }
        }
    */
        

// MORE FUNCTIONS: .filter(), .map(), closure

        console.log([1, -3, 5].filter((value, index)=>{ //uses the existing array
            return value >= 0;
        }))

        // console.log([1,1,3].map((value, index) => {  //creates a new array
        //     return value + 10;
        // }));

        console.log([1,1,3].map(value => value + 10));
        
        </script>
  </body>
</html>